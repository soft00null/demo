// controllers/webhookController.js - Complete webhook controller with all features
// Last Updated: 2025-06-07 22:04:46 UTC by soft00null
const admin = require('firebase-admin');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const logger = require('../utils/logger');
const { generateTicketId, formatPhoneNumber, sanitizeInput, formatTimestamp, containsDevanagari } = require('../utils/helpers');

// Import services with CORRECT function names
const {
  ensureCitizenExists,
  getCitizenBotMode,
  saveChatMessage,
  getConversationContext,
  updateCitizenEthicalScore,
  updateCitizenStats,
  checkDuplicateComplaint,
  createDraftComplaint,
  confirmComplaint,
  cancelComplaint,
  getUserComplaintStatus,
  geocodeAddress,
  getMediaUrl,
  downloadAndUploadImage,
  createTicketRecord,
  addUserToComplaintFollowUp
} = require('../services/firebaseService');

const {
  processMessageWithAI,
  analyzeIntent,
  checkComplaintSimilarity,
  isComplaintStatusQuery,
  calculateEthicalScore,
  categorizeDepartment,
  assessComplaintPriority,
  categorizeComplaintType,
  transcribeAudio,
  analyzeImageContent,
  detectLanguage
} = require('../services/aiService');

// FIXED: Import with correct function names
const {
  sendTextMessage,    // FIXED: Added missing import
  sendImageMessage,
  sendQuickReply,
  sendListMessage,
  sendLocationRequest,
  sendInteractive,
  markMessageAsRead
} = require('../services/whatsappService');

// Configuration constants
const WEBHOOK_VERSION = '2.0.0';
const MAX_PROCESSING_TIME = 30000; // 30 seconds
const RATE_LIMIT_WINDOW = 60000; // 1 minute
const RATE_LIMIT_MAX_MESSAGES = 20;
const WEBHOOK_UPDATED = '2025-06-07 22:04:46 UTC';
const UPDATED_BY = 'soft00null';

// In-memory rate limiting store
const rateLimitStore = new Map();

/*
 * Main webhook handler for WhatsApp Cloud API
 */
async function handleWebhook(req, res) {
  const requestId = generateTicketId(8);
  const startTime = Date.now();
  
  try {
    logger.webhook('üöÄ Webhook request received', {
      requestId,
      method: req.method,
      userAgent: req.get('User-Agent'),
      contentType: req.get('Content-Type'),
      bodySize: JSON.stringify(req.body).length,
      timestamp: new Date().toISOString(),
      version: WEBHOOK_VERSION,
      updatedBy: UPDATED_BY
    });

    const body = req.body;
    
    // Validate webhook object
    if (!body.object || body.object !== 'whatsapp_business_account') {
      logger.warning('‚ùì Invalid webhook object', { 
        object: body.object,
        requestId
      });
      return res.sendStatus(404);
    }

    // Handle incoming messages
    if (body.entry?.[0]?.changes?.[0]?.value?.messages) {
      await processIncomingMessage(body, requestId);
      return res.sendStatus(200);
    }

    // Handle message status updates
    if (body.entry?.[0]?.changes?.[0]?.value?.statuses) {
      await processMessageStatus(body, requestId);
      return res.sendStatus(200);
    }

    // Handle other webhook events
    logger.debug('üìÑ Other webhook event received', {
      requestId,
      eventType: body.entry?.[0]?.changes?.[0]?.field || 'unknown'
    });

    res.sendStatus(200);
  } catch (error) {
    const processingTime = Date.now() - startTime;
    logger.critical('üí• Webhook processing error', {
      error: error.message,
      stack: error.stack,
      requestId,
      processingTime,
      body: JSON.stringify(req.body).substring(0, 500),
      timestamp: new Date().toISOString()
    });
    
    res.status(500).json({
      error: 'Internal server error',
      requestId,
      timestamp: new Date().toISOString(),
      version: WEBHOOK_VERSION
    });
  }
}

/*
 * Process incoming WhatsApp message with comprehensive handling
 */
async function processIncomingMessage(body, requestId) {
  try {
    const messageData = body.entry[0].changes[0].value.messages[0];
    const metadata = body.entry[0].changes[0].value.metadata;
    const contactData = body.entry[0].changes[0].value.contacts?.[0];
    
    const phoneNumber = formatPhoneNumber(messageData.from);
    const displayName = contactData?.profile?.name || 'Unknown User';
    const messageType = messageData.type;
    const messageId = messageData.id;
    const botPhoneNumber = metadata.display_phone_number;
    
    logger.webhook('üì® Processing incoming message', {
      requestId,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      displayName,
      messageType,
      messageId,
      timestamp: new Date().toISOString()
    });

    // Rate limiting check
    if (await isRateLimited(phoneNumber)) {
      await handleRateLimit(phoneNumber, messageType);
      return;
    }

    // Log message preview for debugging
    logMessagePreview(messageData, messageType);

    // Ensure citizen exists in database
    await ensureCitizenExists(phoneNumber, displayName);

    // Mark message as read
    await markMessageAsRead(messageId);

    // Route message based on type
    switch (messageType) {
      case 'text':
        await handleTextMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'audio':
        await handleAudioMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'image':
        await handleImageMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'location':
        await handleLocationMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'interactive':
        await handleInteractiveMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'document':
        await handleDocumentMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'video':
        await handleVideoMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'sticker':
        await handleStickerMessage(messageData, phoneNumber, displayName, requestId);
        break;
      case 'contacts':
        await handleContactMessage(messageData, phoneNumber, displayName, requestId);
        break;
      default:
        logger.warning(`‚ùì Unsupported message type: ${messageType}`, { requestId });
        await sendUnsupportedMessageResponse(phoneNumber, messageType);
        break;
    }

  } catch (error) {
    logger.critical('üí• Error processing incoming message', {
      error: error.message,
      stack: error.stack,
      requestId,
      timestamp: new Date().toISOString()
    });
    
    // Send emergency error response
    const phoneNumber = body.entry?.[0]?.changes?.[0]?.value?.messages?.[0]?.from;
    if (phoneNumber) {
      await sendEmergencyErrorMessage(formatPhoneNumber(phoneNumber));
    }
  }
}

/*
 * Handle text messages with comprehensive AI processing
 */
async function handleTextMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    const messageText = sanitizeInput(messageData.text.body.trim(), 2000);
    const language = detectLanguage(messageText);
    
    logger.ai('üìù Processing text message', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      language,
      textLength: messageText.length,
      requestId,
      timestamp: new Date().toISOString()
    });

    // Get bot mode status
    const botMode = await getCitizenBotMode(phoneNumber);

    // Analyze intent using AI
    const intentAnalysis = await analyzeIntent(messageText, phoneNumber);
    
    // Calculate ethical score
    const ethicalScore = await calculateEthicalScore(messageText);
    
    // Save incoming message with proper timestamps
    await saveChatMessage(phoneNumber, {
      messageId: messageData.id,
      sender: phoneNumber,
      senderName: displayName,
      receiver: 'pcmc_bot',
      messageType: 'text',
      content: messageText,
      intent: intentAnalysis.intent,
      context: intentAnalysis.context,
      conversationState: intentAnalysis.state,
      language,
      ethicalScore,
      confidence: intentAnalysis.confidence,
      botModeEnabled: botMode,
      requestId
    });

    // Update citizen's ethical score
    await updateCitizenEthicalScore(phoneNumber, ethicalScore);

    if (!botMode) {
      logger.info(`üîá Bot mode disabled for ${phoneNumber.replace(/^91/, 'XXX-XXX-')}. Message stored only.`);
      return;
    }

    // Route based on intent
    switch (intentAnalysis.intent) {
      case 'complaint_status':
        await handleComplaintStatusQuery(phoneNumber, displayName, intentAnalysis, language, requestId);
        break;
      case 'complaint':
        await handleComplaintFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId);
        break;
      case 'query':
        await handleQueryFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId);
        break;
      case 'greeting':
        await handleGreetingFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId);
        break;
      case 'small_talk':
        await handleSmallTalkFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId);
        break;
      default:
        await handleGeneralConversation(messageText, phoneNumber, displayName, intentAnalysis, language, requestId);
        break;
    }

  } catch (error) {
    logger.critical('üí• Error handling text message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
    
    const errorMessage = language === 'marathi' 
      ? 'üòî ‡§Æ‡§æ‡§´ ‡§ï‡§∞‡§æ, ‡§Æ‡•Ä ‡§∏‡§ß‡•ç‡§Ø‡§æ ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§ ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.\n\nüìû ‡§§‡§æ‡§§‡§°‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä: 020-27475000\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*'
      : 'üòî Sorry, I cannot help right now. Please try again.\n\nüìû For urgent help: 020-27475000\n\nüèõÔ∏è *PCMC Service*';
    await sendText(phoneNumber, errorMessage);
  }
}

/*
 * FEATURE 1: Handle complaint status queries with detailed information
 */
async function handleComplaintStatusQuery(phoneNumber, displayName, intentAnalysis, language, requestId) {
  try {
    logger.complaint('üìã Processing complaint status query', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      language,
      requestId,
      timestamp: new Date().toISOString()
    });

    // Get user's complaints
    const complaints = await getUserComplaintStatus(phoneNumber);

    if (complaints.length === 0) {
      const noComplaintsMessage = language === 'marathi'
        ? `üìã *‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞‡•Ä‡§Ç‡§ö‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡•Ä*\n\nüë§ *‡§®‡§æ‡§ó‡§∞‡§ø‡§ï:* ${displayName}\nüì± *‡§´‡•ã‡§®:* ${phoneNumber.replace(/^91/, 'XXX-XXX-')}\n\n‚ùå *‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§®‡§æ‡§µ‡•á ‡§ï‡•ã‡§£‡§§‡•ç‡§Ø‡§æ‡§π‡•Ä ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞‡•Ä ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•á‡§≤‡•ç‡§Ø‡§æ ‡§®‡§æ‡§π‡•Ä‡§§.*\n\nüí° *‡§®‡§µ‡•Ä‡§® ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§®‡•ã‡§Ç‡§¶‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä:*\n‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§´‡•ã‡§ü‡•ã ‡§™‡§æ‡§†‡§µ‡§æ\n\nüìû *‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä:* 020-27475000\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`
        : `üìã *Your Complaint Status*\n\nüë§ *Citizen:* ${displayName}\nüì± *Phone:* ${phoneNumber.replace(/^91/, 'XXX-XXX-')}\n\n‚ùå *No complaints found in your name.*\n\nüí° *To register new complaint:*\nType your issue or send a photo\n\nüìû *For help:* 020-27475000\n\nüèõÔ∏è *PCMC Service*`;
      
      await sendText(phoneNumber, noComplaintsMessage);
      return;
    }

    // Format complaints status with enhanced display
    const statusMessage = formatComplaintStatusMessage(complaints, displayName, phoneNumber, language);
    await sendText(phoneNumber, statusMessage);

    // Save status query response
    await saveChatMessage(phoneNumber, {
      messageId: generateTicketId(8),
      sender: 'pcmc_bot',
      senderName: 'PCMC Assistant',
      receiver: phoneNumber,
      messageType: 'text',
      content: statusMessage,
      intent: 'status_response',
      context: 'complaint_status',
      conversationState: 'status_provided',
      language,
      ethicalScore: 10,
      botModeEnabled: true,
      aiMetadata: {
        complaintsCount: complaints.length,
        queryType: 'status_check'
      },
      requestId
    });

    logger.success('‚úÖ Complaint status query completed', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      complaintsFound: complaints.length,
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error handling complaint status query', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
    
    const errorMessage = language === 'marathi'
      ? 'üòî ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§∏‡•ç‡§•‡§ø‡§§‡•Ä ‡§Æ‡§ø‡§≥‡§µ‡§ø‡§§‡§æ‡§®‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§≤‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.'
      : 'üòî Error retrieving complaint status. Please try again.';
    await sendText(phoneNumber, errorMessage);
  }
}

/*
 * Format complaint status message with progress bars and detailed information
 */
function formatComplaintStatusMessage(complaints, displayName, phoneNumber, language) {
  const isMarathi = language === 'marathi';
  
  // Header
  let message = isMarathi 
    ? `üìã *‡§§‡•Å‡§Æ‡§ö‡•ç‡§Ø‡§æ ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞‡•Ä‡§Ç‡§ö‡•Ä ‡§∏‡•ç‡§•‡§ø‡§§‡•Ä* | *Your Complaint Status*\n\nüë§ *‡§®‡§æ‡§ó‡§∞‡§ø‡§ï:* ${displayName}\nüì± *‡§è‡§ï‡•Ç‡§£ ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞‡•Ä:* ${complaints.length}\nüìÖ *‡§§‡§Ø‡§æ‡§∞ ‡§ï‡•á‡§≤‡•á:* ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}\n\n`
    : `üìã *Your Complaint Status*\n\nüë§ *Citizen:* ${displayName}\nüì± *Total Complaints:* ${complaints.length}\nüìÖ *Generated:* ${new Date().toLocaleString('en-IN', { timeZone: 'Asia/Kolkata' })}\n\n`;

  // Process each complaint
  complaints.forEach((complaint, index) => {
    const statusEmoji = getStatusEmoji(complaint.status);
    const priorityEmoji = getPriorityEmoji(complaint.priority);
    const progressBar = getProgressBar(complaint.workflow.completionPercentage);
    const createdDate = formatDate(complaint.createdAt);
    
    message += `${index + 1}. ${statusEmoji} *${complaint.category}*\n`;
    message += `   üé´ *${isMarathi ? '‡§§‡§ø‡§ï‡•Ä‡§ü' : 'Ticket'}:* ${complaint.ticketId}\n`;
    message += `   üèõÔ∏è *${isMarathi ? '‡§µ‡§ø‡§≠‡§æ‡§ó' : 'Department'}:* ${complaint.department}\n`;
    message += `   ${priorityEmoji} *${isMarathi ? '‡§™‡•ç‡§∞‡§æ‡§ß‡§æ‡§®‡•ç‡§Ø‡§§‡§æ' : 'Priority'}:* ${complaint.priority.toUpperCase()}\n`;
    message += `   üìà *${isMarathi ? '‡§™‡•ç‡§∞‡§ó‡§§‡•Ä' : 'Progress'}:* ${progressBar} ${complaint.workflow.completionPercentage}%\n`;
    message += `   üìù "${complaint.description}"\n`;
    message += `   üìÖ *${isMarathi ? '‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•á' : 'Registered'}:* ${createdDate}\n`;
    
    if (complaint.estimatedResolutionTime) {
      message += `   ‚è±Ô∏è *${isMarathi ? '‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§' : 'Expected'}:* ${complaint.estimatedResolutionTime} ${isMarathi ? '‡§§‡§æ‡§∏' : 'hours'}\n`;
    }
    
    message += `\n`;
  });

  // Footer
  message += isMarathi
    ? `‚ùì *‡§§‡§ï‡•ç‡§∞‡§æ‡§∞‡•Ä‡§¨‡§¶‡•ç‡§¶‡§≤ ‡§™‡•ç‡§∞‡§∂‡•ç‡§®?* ‡§§‡§ø‡§ï‡•Ä‡§ü ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï ‡§¶‡•ç‡§Ø‡§æ\n‚ùì *Questions about complaint?* Provide ticket number\n\nüìû *‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä:* 020-27475000\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`
    : `‚ùì *Questions about complaint?* Provide ticket number\n\nüìû *For help:* 020-27475000\n\nüèõÔ∏è *PCMC Service*`;

  return message;
}

/*
 * Handle complaint registration flow with duplicate detection
 */
/**
 * ENHANCED: Handle complaint registration flow with better duplicate detection
 */
async function handleComplaintFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId, imageUrl = null) {
  try {
    logger.complaint('üìù Processing enhanced complaint registration', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      language,
      descriptionLength: messageText.length,
      hasImage: !!imageUrl,
      requestId
    });

    // ENHANCED: Check for duplicate complaints with location and image
    const duplicateCheck = await checkDuplicateComplaint(messageText, phoneNumber, null, imageUrl);
    
    if (duplicateCheck.isDuplicate) {
      logger.complaint('üîÑ Enhanced duplicate complaint detected', {
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
        existingTicket: duplicateCheck.ticketId,
        similarity: duplicateCheck.similarity,
        confidence: duplicateCheck.confidence,
        distance: duplicateCheck.distance,
        requestId
      });

      // Enhanced duplicate message with detailed breakdown
      const duplicateMessage = language === 'marathi'
        ? `üîÑ **‡§∏‡§Æ‡§æ‡§® ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§Ü‡§ß‡•Ä ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•Ä ‡§Ü‡§π‡•á**\n\nüé´ **‡§Ö‡§∏‡•ç‡§§‡§ø‡§§‡•ç‡§µ‡§æ‡§§ ‡§Ö‡§∏‡§≤‡•á‡§≤‡•Ä ‡§§‡§ø‡§ï‡•Ä‡§ü:** ${duplicateCheck.ticketId}\nüìä **‡§∏‡•ç‡§•‡§ø‡§§‡•Ä:** ${duplicateCheck.status}\nüéØ **‡§∏‡§Æ‡§æ‡§®‡§§‡§æ:** ${Math.round(duplicateCheck.similarity * 100)}%\nüéØ **‡§µ‡§ø‡§∂‡•ç‡§µ‡§∏‡§®‡•Ä‡§Ø‡§§‡§æ:** ${Math.round(duplicateCheck.confidence * 100)}%\nüèõÔ∏è **‡§µ‡§ø‡§≠‡§æ‡§ó:** ${duplicateCheck.department}\n${duplicateCheck.distance ? `üìç **‡§Ö‡§Ç‡§§‡§∞:** ${Math.round(duplicateCheck.distance * 1000)}m\n` : ''}\nüìã **‡§Æ‡•Ç‡§≥ ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞:** "${duplicateCheck.originalComplaint}"\n\nüìä **‡§§‡§™‡§∂‡•Ä‡§≤‡§µ‡§æ‡§∞ ‡§µ‡§ø‡§∂‡•ç‡§≤‡•á‡§∑‡§£:**\n${duplicateCheck.explanation}\n\n‚úÖ ‡§Ü‡§Æ‡•ç‡§π‡•Ä ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§Ö‡§™‡§°‡•á‡§ü ‡§Ø‡§æ‡§¶‡•Ä‡§§ ‡§ú‡•ã‡§°‡§≤‡•á ‡§Ü‡§π‡•á. ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§Ø‡§æ ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§∏‡•ç‡§•‡§ø‡§§‡•Ä‡§¨‡§¶‡•ç‡§¶‡§≤ ‡§Ö‡§™‡§°‡•á‡§ü ‡§Æ‡§ø‡§≥‡§§‡•Ä‡§≤.\n\n‚ùì **‡§µ‡•á‡§ó‡§≥‡•Ä ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§®‡•ã‡§Ç‡§¶‡§µ‡§æ‡§Ø‡§ö‡•Ä ‡§Ü‡§π‡•á ‡§ï‡§æ?** ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Ö‡§ß‡§ø‡§ï ‡§§‡§™‡§∂‡•Ä‡§≤ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§µ‡•á‡§ó‡§≥‡•á ‡§∏‡•ç‡§•‡§æ‡§® ‡§¶‡•ç‡§Ø‡§æ.\n\nüèõÔ∏è **PCMC ‡§∏‡•á‡§µ‡§æ**`
        : `üîÑ **Similar complaint already registered**\n\nüé´ **Existing Ticket:** ${duplicateCheck.ticketId}\nüìä **Status:** ${duplicateCheck.status}\nüéØ **Similarity:** ${Math.round(duplicateCheck.similarity * 100)}%\nüéØ **Confidence:** ${Math.round(duplicateCheck.confidence * 100)}%\nüèõÔ∏è **Department:** ${duplicateCheck.department}\n${duplicateCheck.distance ? `üìç **Distance:** ${Math.round(duplicateCheck.distance * 1000)}m\n` : ''}\nüìã **Original Complaint:** "${duplicateCheck.originalComplaint}"\n\nüìä **Detailed Analysis:**\n${duplicateCheck.explanation}\n\n‚úÖ We've added you to the updates list. You'll receive updates about this complaint's progress.\n\n‚ùì **Want to register different complaint?** Please provide more details or different location.\n\nüèõÔ∏è **PCMC Service**`;

      await sendTextMessage(phoneNumber, duplicateMessage);
      
      // Save enhanced duplicate detection response
      await saveChatMessage(phoneNumber, {
        messageId: generateTicketId(8),
        sender: 'pcmc_bot',
        senderName: 'PCMC Assistant',
        receiver: phoneNumber,
        messageType: 'text',
        content: duplicateMessage,
        intent: 'duplicate_detected',
        context: 'complaint_registration',
        conversationState: 'duplicate_handled',
        language,
        ethicalScore: 10,
        botModeEnabled: true,
        aiMetadata: {
          duplicateTicketId: duplicateCheck.ticketId,
          similarity: duplicateCheck.similarity,
          confidence: duplicateCheck.confidence,
          breakdown: duplicateCheck.breakdown,
          originalComplaint: duplicateCheck.originalComplaint,
          analysisType: 'enhanced_multi_parameter'
        },
        requestId
      });

      return;
    }

    // No duplicate found - proceed with normal complaint creation
    const draftComplaint = await createDraftComplaint(messageText, phoneNumber, intentAnalysis, imageUrl);
    
    // Send confirmation request with detailed information
    await sendComplaintConfirmation(phoneNumber, draftComplaint, language);

    logger.success('‚úÖ Enhanced complaint flow initiated successfully', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      complaintId: draftComplaint.id,
      department: draftComplaint.department,
      priority: draftComplaint.priority,
      duplicateCheckScore: duplicateCheck.highestScore || 0,
      requestId
    });

  } catch (error) {
    logger.critical('üí• Error in enhanced complaint flow', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      stack: error.stack
    });
    
    const errorMessage = language === 'marathi'
      ? 'üòî ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§®‡•ã‡§Ç‡§¶‡§µ‡§§‡§æ‡§®‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§≤‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.'
      : 'üòî Error registering complaint. Please try again.';
    await sendTextMessage(phoneNumber, errorMessage);
  }
}

/*
 * FIXED: Send complaint confirmation with enhanced details
 */
async function sendComplaintConfirmation(phoneNumber, complaintData, language) {
  try {
    const isMarathi = language === 'marathi';
    
    const confirmationMessage = {
      messaging_product: 'whatsapp',
      recipient_type: 'individual',
      to: phoneNumber,
      type: 'interactive',
      interactive: {
        type: 'button',
        body: {
          text: isMarathi
            ? `üèõÔ∏è *PCMC ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§™‡•Å‡§∑‡•ç‡§ü‡•Ä‡§ï‡§∞‡§£*\n\nüìã *‡§§‡§ï‡•ç‡§∞‡§æ‡§∞:* ${complaintData.description.substring(0, 100)}${complaintData.description.length > 100 ? '...' : ''}\n\nüèõÔ∏è *‡§µ‡§ø‡§≠‡§æ‡§ó:* ${complaintData.department}\nüî¥ *‡§™‡•ç‡§∞‡§æ‡§ß‡§æ‡§®‡•ç‡§Ø‡§§‡§æ:* ${complaintData.priority.toUpperCase()}\nüìä *‡§™‡•ç‡§∞‡§ï‡§æ‡§∞:* ${complaintData.category}\n‚è±Ô∏è *‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§µ‡•á‡§≥:* ${complaintData.estimatedResolutionTime} ‡§§‡§æ‡§∏\n\n‡§π‡•Ä ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§Ö‡§ß‡§ø‡§ï‡•É‡§§ ‡§∞‡•Ç‡§™‡§æ‡§§ ‡§®‡•ã‡§Ç‡§¶‡§µ‡§æ‡§Ø‡§ö‡•Ä ‡§Ü‡§π‡•á ‡§ï‡§æ?\n\n‚ö†Ô∏è *‡§™‡•Å‡§¢‡•Ä‡§≤ ‡§™‡§æ‡§Ø‡§∞‡•Ä:* ‡§§‡•Å‡§Æ‡§ö‡•á ‡§Ö‡§ö‡•Ç‡§ï ‡§∏‡•ç‡§•‡§æ‡§® ‡§∂‡•á‡§Ö‡§∞ ‡§ï‡§∞‡§£‡•á ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§Ü‡§π‡•á.`
            : `üèõÔ∏è *PCMC Complaint Confirmation*\n\nüìã *Complaint:* ${complaintData.description.substring(0, 100)}${complaintData.description.length > 100 ? '...' : ''}\n\nüèõÔ∏è *Department:* ${complaintData.department}\nüî¥ *Priority:* ${complaintData.priority.toUpperCase()}\nüìä *Category:* ${complaintData.category}\n‚è±Ô∏è *Expected Time:* ${complaintData.estimatedResolutionTime} hours\n\nWould you like to register this as an official complaint?\n\n‚ö†Ô∏è *Next Step:* You'll need to share your exact location.`
        },
        action: {
          buttons: [
            {
              type: 'reply',
              reply: {
                id: `confirm_complaint_${complaintData.id}`,
                title: isMarathi ? '‚úÖ ‡§™‡•Å‡§∑‡•ç‡§ü‡•Ä ‡§ï‡§∞‡§æ' : '‚úÖ Confirm'
              }
            },
            {
              type: 'reply',
              reply: {
                id: `cancel_complaint_${complaintData.id}`,
                title: isMarathi ? '‚ùå ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡§æ' : '‚ùå Cancel'
              }
            }
          ]
        }
      }
    };

    // ‚úÖ FIXED: Use sendInteractive instead of sendInteractiveMessage
    await sendInteractive(confirmationMessage);
    
    logger.success('‚úÖ Complaint confirmation sent successfully', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      complaintId: complaintData.id,
      department: complaintData.department,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    logger.critical('üö® CRITICAL: üí• Error sending complaint confirmation', {
      version: WEBHOOK_VERSION,
      environment: process.env.NODE_ENV || 'development',
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      complaintId: complaintData.id,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      updatedBy: UPDATED_BY
    });
    
    // Fallback: Send text message instead of interactive
    const fallbackMessage = language === 'marathi'
      ? `üèõÔ∏è *PCMC ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§™‡•Å‡§∑‡•ç‡§ü‡•Ä‡§ï‡§∞‡§£*\n\nüìã ${complaintData.description.substring(0, 100)}...\n\n‚úÖ "‡§π‡•ã‡§Ø" ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ - ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§®‡•ã‡§Ç‡§¶‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä\n‚ùå "‡§®‡§æ‡§π‡•Ä" ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ - ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`
      : `üèõÔ∏è *PCMC Complaint Confirmation*\n\nüìã ${complaintData.description.substring(0, 100)}...\n\n‚úÖ Type "Yes" - to register complaint\n‚ùå Type "No" - to cancel\n\nüèõÔ∏è *PCMC Service*`;
    
    await sendText(phoneNumber, fallbackMessage);
  }
}

/*
 * Handle audio messages with transcription and processing
 */
async function handleAudioMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    logger.ai('üéôÔ∏è Processing audio message', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      mediaId: messageData.audio.id,
      duration: messageData.audio.voice ? 'voice_note' : 'audio_file',
      requestId
    });

    const botMode = await getCitizenBotMode(phoneNumber);
    let language = 'auto'; // FIXED: Declare language variable
    
    try {
      // Download and transcribe audio
      const mediaUrl = await getMediaUrl(messageData.audio.id);
      const localPath = await downloadAudioFile(mediaUrl, messageData.audio.id);
      const transcript = await transcribeAudio(localPath);
      
      logger.ai('‚úÖ Audio transcribed successfully', {
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
        transcriptLength: transcript.length,
        requestId
      });

      // FIXED: Detect language from transcript
      language = detectLanguage(transcript);
      const ethicalScore = await calculateEthicalScore(transcript);
      const intentAnalysis = await analyzeIntent(transcript, phoneNumber);

      // Save audio message
      await saveChatMessage(phoneNumber, {
        messageId: messageData.id,
        sender: phoneNumber,
        senderName: displayName,
        receiver: 'pcmc_bot',
        messageType: 'audio',
        content: transcript,
        audioMetadata: {
          mediaId: messageData.audio.id,
          mimeType: messageData.audio.mime_type,
          voice: messageData.audio.voice || false
        },
        intent: intentAnalysis.intent,
        context: intentAnalysis.context,
        conversationState: intentAnalysis.state,
        language,
        ethicalScore,
        confidence: intentAnalysis.confidence,
        botModeEnabled: botMode,
        requestId
      });

      // Update citizen's ethical score
      await updateCitizenEthicalScore(phoneNumber, ethicalScore);

      // Clean up audio file
      if (fs.existsSync(localPath)) {
        fs.unlinkSync(localPath);
      }

      if (!botMode) {
        logger.info(`üîá Bot mode disabled for ${phoneNumber.replace(/^91/, 'XXX-XXX-')}. Audio transcribed and stored only.`);
        return;
      }

      // Process transcribed content based on intent
      switch (intentAnalysis.intent) {
        case 'complaint_status':
          await handleComplaintStatusQuery(phoneNumber, displayName, intentAnalysis, language, requestId);
          break;
        case 'complaint':
          await handleComplaintFlow(transcript, phoneNumber, displayName, intentAnalysis, language, requestId);
          break;
        default:
          await handleGeneralConversation(transcript, phoneNumber, displayName, intentAnalysis, language, requestId);
          break;
      }

    } catch (audioError) {
      logger.critical('üí• Error processing audio', {
        error: audioError.message,
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
        mediaId: messageData.audio.id,
        requestId,
        stack: audioError.stack
      });
      
      // FIXED: Use proper language variable
      const errorMessage = language === 'marathi'
        ? 'üòî ‡§ë‡§°‡§ø‡§ì ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡§∞‡§§‡§æ‡§®‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§≤‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§Æ‡§ú‡§ï‡•Ç‡§∞ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡§æ‡§†‡§µ‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.\n\nüèõÔ∏è **PCMC ‡§∏‡•á‡§µ‡§æ**'
        : 'üòî Error processing audio. Please send text message or try again.\n\nüèõÔ∏è **PCMC Service**';
      await sendTextMessage(phoneNumber, errorMessage);
    }

  } catch (error) {
    logger.critical('üí• Error handling audio message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      stack: error.stack
    });
    
    // Fallback error message
    const fallbackMessage = 'üòî Error processing your audio. Please try sending text message.\n\nüìû For urgent help: 020-27475000\n\nüèõÔ∏è **PCMC Service**';
    
    try {
      await sendTextMessage(phoneNumber, fallbackMessage);
    } catch (sendError) {
      logger.critical('üí• Failed to send error message', {
        error: sendError.message,
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-')
      });
    }
  }
}

/*
 * Handle image messages with AI analysis
 */
async function handleImageMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    logger.ai('üñºÔ∏è Processing image message', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      mediaId: messageData.image.id,
      hasCaption: !!messageData.image.caption,
      requestId
    });

    const botMode = await getCitizenBotMode(phoneNumber);
    let language = 'auto'; // FIXED: Declare language variable
    
    try {
      // Download and upload image
      const mediaUrl = await getMediaUrl(messageData.image.id);
      const imageUrl = await downloadAndUploadImage(mediaUrl, messageData.image.id);
      
      // Analyze image content with AI
      const imageAnalysis = await analyzeImageContent(imageUrl);
      const caption = messageData.image.caption || '';
      const fullContent = caption ? `${caption}\n\nImage Analysis: ${imageAnalysis}` : imageAnalysis;
      
      logger.ai('‚úÖ Image analyzed successfully', {
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
        analysisLength: imageAnalysis.length,
        hasCaption: !!caption,
        requestId
      });

      // FIXED: Detect language from content
      language = detectLanguage(fullContent);
      const ethicalScore = await calculateEthicalScore(fullContent);
      const intentAnalysis = await analyzeIntent(fullContent, phoneNumber);

      // Save image message
      await saveChatMessage(phoneNumber, {
        messageId: messageData.id,
        sender: phoneNumber,
        senderName: displayName,
        receiver: 'pcmc_bot',
        messageType: 'image',
        content: fullContent,
        imageUrl,
        imageMetadata: {
          mediaId: messageData.image.id,
          mimeType: messageData.image.mime_type,
          caption: caption || null,
          sha256: messageData.image.sha256 || null
        },
        intent: intentAnalysis.intent,
        context: intentAnalysis.context,
        conversationState: intentAnalysis.state,
        language,
        ethicalScore,
        confidence: intentAnalysis.confidence,
        botModeEnabled: botMode,
        requestId
      });

      // Update citizen's ethical score
      await updateCitizenEthicalScore(phoneNumber, ethicalScore);

      if (!botMode) {
        logger.info(`üîá Bot mode disabled for ${phoneNumber.replace(/^91/, 'XXX-XXX-')}. Image analyzed and stored only.`);
        return;
      }

      // Process image content based on intent
      switch (intentAnalysis.intent) {
        case 'complaint':
          await handleComplaintFlow(fullContent, phoneNumber, displayName, intentAnalysis, language, requestId, imageUrl);
          break;
        default:
          await handleGeneralConversation(fullContent, phoneNumber, displayName, intentAnalysis, language, requestId);
          break;
      }

    } catch (imageError) {
      logger.critical('üí• Error processing image', {
        error: imageError.message,
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
        mediaId: messageData.image.id,
        requestId,
        stack: imageError.stack
      });
      
      // FIXED: Use proper language variable
      const errorMessage = language === 'marathi'
        ? 'üòî ‡§´‡•ã‡§ü‡•ã ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§ï‡§∞‡§§‡§æ‡§®‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§≤‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.\n\nüèõÔ∏è **PCMC ‡§∏‡•á‡§µ‡§æ**'
        : 'üòî Error processing image. Please try again.\n\nüèõÔ∏è **PCMC Service**';
      await sendTextMessage(phoneNumber, errorMessage);
    }

  } catch (error) {
    logger.critical('üí• Error handling image message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      stack: error.stack
    });
    
    // Fallback error message
    const fallbackMessage = 'üòî Error processing your image. Please try sending text message.\n\nüìû For urgent help: 020-27475000\n\nüèõÔ∏è **PCMC Service**';
    
    try {
      await sendTextMessage(phoneNumber, fallbackMessage);
    } catch (sendError) {
      logger.critical('üí• Failed to send error message', {
        error: sendError.message,
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-')
      });
    }
  }
}

/*
 * Handle location messages with complaint confirmation
 */
async function handleLocationMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    const latitude = messageData.location.latitude;
    const longitude = messageData.location.longitude;
    const locationName = messageData.location.name || null;
    
    logger.complaint('üìç Processing location message', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      latitude,
      longitude,
      hasName: !!locationName,
      requestId,
      timestamp: new Date().toISOString()
    });

    try {
      // Geocode coordinates to address
      const address = await geocodeAddress(latitude, longitude);
      
      const locationData = {
        latitude,
        longitude,
        address,
        name: locationName,
        source: 'whatsapp_location',
        accuracy: messageData.location.accuracy || null
      };

      // Save location message
      await saveChatMessage(phoneNumber, {
        messageId: messageData.id,
        sender: phoneNumber,
        senderName: displayName,
        receiver: 'pcmc_bot',
        messageType: 'location',
        content: `Location shared: ${address}`,
        location: locationData,
        intent: 'location_sharing',
        context: 'complaint_location',
        conversationState: 'location_received',
        language: 'auto',
        ethicalScore: 9,
        botModeEnabled: true,
        requestId
      });

      // Check for pending draft complaints requiring location
      const pendingComplaint = await getPendingComplaintForUser(phoneNumber);
      
      if (pendingComplaint) {
        // Confirm complaint with location
        const ticketId = await confirmComplaint(pendingComplaint.id, locationData);
        
        const language = detectLanguage(pendingComplaint.description);
        const successMessage = language === 'marathi'
          ? `‚úÖ *‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä‡§∞‡§ø‡§§‡•ç‡§Ø‡§æ ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•Ä!*\n\nüé´ *‡§§‡§ø‡§ï‡•Ä‡§ü ‡§ï‡•ç‡§∞‡§Æ‡§æ‡§Ç‡§ï:* ${ticketId}\nüèõÔ∏è *‡§µ‡§ø‡§≠‡§æ‡§ó:* ${pendingComplaint.department}\nüî¥ *‡§™‡•ç‡§∞‡§æ‡§ß‡§æ‡§®‡•ç‡§Ø‡§§‡§æ:* ${pendingComplaint.priority}\nüìç *‡§∏‡•ç‡§•‡§æ‡§®:* ${address}\n\nüìã *‡§§‡§ï‡•ç‡§∞‡§æ‡§∞:* ${pendingComplaint.description.substring(0, 100)}${pendingComplaint.description.length > 100 ? '...' : ''}\n\n‚è±Ô∏è *‡§Ö‡§™‡•á‡§ï‡•ç‡§∑‡§ø‡§§ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§µ‡§æ‡§π‡•Ä:* ${pendingComplaint.estimatedResolutionTime} ‡§§‡§æ‡§∏\n\n‚úÖ PCMC ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§™‡§æ‡§π‡•Ä‡§≤ ‡§Ü‡§£‡§ø ‡§Ø‡•ã‡§ó‡•ç‡§Ø ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§µ‡§æ‡§π‡•Ä ‡§ï‡§∞‡•á‡§≤. ‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`
          : `‚úÖ *Complaint registered successfully!*\n\nüé´ *Ticket ID:* ${ticketId}\nüèõÔ∏è *Department:* ${pendingComplaint.department}\nüî¥ *Priority:* ${pendingComplaint.priority}\nüìç *Location:* ${address}\n\nüìã *Complaint:* ${pendingComplaint.description.substring(0, 100)}${pendingComplaint.description.length > 100 ? '...' : ''}\n\n‚è±Ô∏è *Expected Action:* ${pendingComplaint.estimatedResolutionTime} hours\n\n‚úÖ PCMC will review your complaint and take appropriate action. Thank you!\n\nüèõÔ∏è *PCMC Service*`;
        
        await sendText(phoneNumber, successMessage);
        
        logger.success('‚úÖ Complaint confirmed with location', {
          phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
          ticketId,
          complaintId: pendingComplaint.id,
          department: pendingComplaint.department,
          requestId,
          timestamp: new Date().toISOString()
        });
        
      } else {
        // No pending complaint, acknowledge location
        const acknowledgmentMessage = `üìç *‡§∏‡•ç‡§•‡§æ‡§® ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ù‡§æ‡§≤‡•á* | *Location Received*\n\nüìç ${address}\n\n‚úÖ ‡§§‡•Å‡§Æ‡§ö‡•á ‡§∏‡•ç‡§•‡§æ‡§® ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•á ‡§Ü‡§π‡•á.\n‚úÖ Your location has been recorded.\n\n‚ùì *PCMC ‡§ö‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∂‡•Ä ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•á?*\n‚ùì *How can PCMC help you today?*\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
        
        await sendText(phoneNumber, acknowledgmentMessage);
      }

    } catch (locationError) {
      logger.critical('üí• Error processing location', {
        error: locationError.message,
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
        latitude,
        longitude,
        requestId,
        timestamp: new Date().toISOString()
      });
      
      const errorMessage = `üòî *‡§∏‡•ç‡§•‡§æ‡§® ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§§‡•ç‡§∞‡•Å‡§ü‡•Ä* | *Location Processing Error*\n\n‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.\nPlease try again.\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
      await sendText(phoneNumber, errorMessage);
    }

  } catch (error) {
    logger.critical('üí• Error handling location message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle interactive messages (buttons, lists, etc.)
 */
async function handleInteractiveMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    logger.webhook('üîò Processing interactive message', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      type: messageData.interactive.type,
      requestId,
      timestamp: new Date().toISOString()
    });

    if (messageData.interactive.type === 'button_reply') {
      const buttonId = messageData.interactive.button_reply.id;
      const buttonTitle = messageData.interactive.button_reply.title;
      
      logger.debug('üîò Button clicked', { buttonId, buttonTitle, requestId });
      
      // Save interactive message
      await saveChatMessage(phoneNumber, {
        messageId: messageData.id,
        sender: phoneNumber,
        senderName: displayName,
        receiver: 'pcmc_bot',
        messageType: 'interactive',
        content: `Button clicked: ${buttonTitle}`,
        interactiveData: { 
          type: 'button_reply',
          buttonId, 
          buttonTitle 
        },
        intent: 'button_click',
        context: 'interactive_response',
        conversationState: 'button_clicked',
        language: 'auto',
        ethicalScore: 9,
        botModeEnabled: true,
        requestId
      });

      // Handle specific button actions
      if (buttonId.startsWith('confirm_complaint_')) {
        const complaintId = buttonId.replace('confirm_complaint_', '');
        await handleComplaintConfirmation(complaintId, phoneNumber, requestId);
      } else if (buttonId.startsWith('cancel_complaint_')) {
        const complaintId = buttonId.replace('cancel_complaint_', '');
        await handleComplaintCancellation(complaintId, phoneNumber, requestId);
      } else {
        // Generic button response
        const response = `‚úÖ *‡§¨‡§ü‡§£ ‡§®‡§ø‡§µ‡§°‡§≤‡•á* | *Button Selected*\n\n"${buttonTitle}"\n\n‡§ï‡§æ‡§Ø ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•ã?\nWhat can I help with?\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
        await sendText(phoneNumber, response);
      }

    } else if (messageData.interactive.type === 'list_reply') {
      const listId = messageData.interactive.list_reply.id;
      const listTitle = messageData.interactive.list_reply.title;
      
      await handleListSelection(listId, listTitle, phoneNumber, displayName, requestId);
      
    } else {
      logger.warning('‚ùì Unsupported interactive type', {
        type: messageData.interactive.type,
        requestId
      });
    }

  } catch (error) {
    logger.critical('üí• Error handling interactive message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      stack: error.stack,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle complaint confirmation
 */
async function handleComplaintConfirmation(complaintId, phoneNumber, requestId) {
  try {
    logger.complaint('‚úÖ Processing complaint confirmation', { 
      complaintId, 
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
    
    // Get draft complaint
    const complaintRef = admin.firestore().collection('complaints').doc(complaintId);
    const complaintDoc = await complaintRef.get();
    
    if (!complaintDoc.exists) {
      await sendText(phoneNumber, 
        '‚ùå ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§∏‡§æ‡§™‡§°‡§≤‡•Ä ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.\n‚ùå Complaint not found. Please try again.\n\nüèõÔ∏è *PCMC Service*'
      );
      return;
    }

    const complaintData = complaintDoc.data();
    const language = detectLanguage(complaintData.description);
    
    // Request WhatsApp location sharing
    const locationMessage = language === 'marathi'
      ? `‚úÖ *‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§™‡•Å‡§∑‡•ç‡§ü ‡§ï‡•á‡§≤‡•Ä!*\n\nüìç *‡§Ü‡§§‡§æ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•á ‡§Ö‡§ö‡•Ç‡§ï ‡§∏‡•ç‡§•‡§æ‡§® ‡§∂‡•á‡§Ö‡§∞ ‡§ï‡§∞‡§æ:*\n\nüì± *WhatsApp ‡§Æ‡§ß‡•ç‡§Ø‡•á:*\n1Ô∏è‚É£ üìé (attach) ‡§¨‡§ü‡§£‡§æ‡§µ‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§æ\n2Ô∏è‚É£ "Location" ‡§®‡§ø‡§µ‡§°‡§æ\n3Ô∏è‚É£ "Send your current location" ‡§®‡§ø‡§µ‡§°‡§æ\n\nüîÑ *‡§ï‡§ø‡§Ç‡§µ‡§æ*\n‡§Æ‡•á‡§∏‡•á‡§ú ‡§¨‡•â‡§ï‡•ç‡§∏‡§Æ‡§ß‡•ç‡§Ø‡•á üìç ‡§Ü‡§Ø‡§ï‡•â‡§®‡§µ‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡§æ\n\n‚ö†Ô∏è *‡§Æ‡§π‡§§‡•ç‡§µ‡§æ‡§ö‡•á:* ‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ï‡•ç‡§§ WhatsApp ‡§ö‡•á location feature ‡§µ‡§æ‡§™‡§∞‡§æ\n\nüéØ *‡§ï‡§æ ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§Ü‡§π‡•á?*\n‚Ä¢ ‡§Ö‡§ö‡•Ç‡§ï ‡§∏‡•ç‡§•‡§æ‡§® ‡§ì‡§≥‡§ñ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä\n‚Ä¢ ‡§Ø‡•ã‡§ó‡•ç‡§Ø ‡§µ‡§ø‡§≠‡§æ‡§ó‡§æ‡§≤‡§æ ‡§™‡§æ‡§†‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä\n‚Ä¢ ‡§ú‡§≤‡§¶ ‡§ï‡§æ‡§∞‡•ç‡§Ø‡§µ‡§æ‡§π‡•Ä‡§∏‡§æ‡§†‡•Ä\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`
      : `‚úÖ *Complaint confirmed!*\n\nüìç *Now please share your exact location:*\n\nüì± *In WhatsApp:*\n1Ô∏è‚É£ Click üìé (attach) button\n2Ô∏è‚É£ Select "Location"\n3Ô∏è‚É£ Choose "Send your current location"\n\nüîÑ *Or*\nClick üìç icon in message box\n\n‚ö†Ô∏è *Important:* Please only use WhatsApp's location feature\n\nüéØ *Why needed?*\n‚Ä¢ To identify exact location\n‚Ä¢ To route to correct department\n‚Ä¢ For faster action\n\nüèõÔ∏è *PCMC Service*`;

    await sendText(phoneNumber, locationMessage);
    
    logger.success('‚úÖ Complaint confirmation processed - location request sent', { 
      complaintId, 
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error confirming complaint', { 
      error: error.message, 
      complaintId, 
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle complaint cancellation
 */
async function handleComplaintCancellation(complaintId, phoneNumber, requestId) {
  try {
    logger.complaint('‚ùå Processing complaint cancellation', { 
      complaintId, 
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
    
    await cancelComplaint(complaintId);
    
    await sendText(phoneNumber,
      `‚ùå *‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡•á‡§≤‡•Ä* | *Complaint Cancelled*\n\n‚úÖ ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§Ø‡§∂‡§∏‡•ç‡§µ‡•Ä‡§∞‡§ø‡§§‡•ç‡§Ø‡§æ ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡•á‡§≤‡•Ä ‡§ó‡•á‡§≤‡•Ä.\n‚úÖ Your complaint has been successfully cancelled.\n\nüí° *‡§®‡§µ‡•Ä‡§® ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§®‡•ã‡§Ç‡§¶‡§µ‡§£‡•ç‡§Ø‡§æ‡§∏‡§æ‡§†‡•Ä:* ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ\nüí° *To register new complaint:* Type your issue\n\n‚ùì *‡§á‡§§‡§∞ ‡§™‡•ç‡§∞‡§∂‡•ç‡§®‡§æ‡§Ç‡§∏‡§æ‡§†‡•Ä ‡§Ü‡§Æ‡•ç‡§π‡•Ä ‡§á‡§•‡•á ‡§Ü‡§π‡•ã‡§§*\n‚ùì *We're here for any other questions*\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`
    );
    
    logger.success('‚úÖ Complaint cancellation processed', { 
      complaintId, 
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error cancelling complaint', { 
      error: error.message, 
      complaintId, 
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle document messages
 */
async function handleDocumentMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    const documentData = messageData.document;
    
    logger.debug('üìÑ Document message received', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      filename: documentData.filename || 'unnamed',
      mimeType: documentData.mime_type,
      requestId,
      timestamp: new Date().toISOString()
    });

    // Save document message
    await saveChatMessage(phoneNumber, {
      messageId: messageData.id,
      sender: phoneNumber,
      senderName: displayName,
      receiver: 'pcmc_bot',
      messageType: 'document',
      content: `Document shared: ${documentData.filename || 'Document'}`,
      documentMetadata: {
        mediaId: documentData.id,
        filename: documentData.filename || null,
        mimeType: documentData.mime_type,
        caption: documentData.caption || null
      },
      intent: 'document_sharing',
      context: 'file_upload',
      conversationState: 'document_received',
      language: 'auto',
      ethicalScore: 8,
      botModeEnabled: true,
      requestId
    });

    const response = `üìÑ *‡§¶‡§∏‡•ç‡§§‡§ê‡§µ‡§ú ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ù‡§æ‡§≤‡§æ* | *Document Received*\n\nüìé *‡§´‡§æ‡§á‡§≤:* ${documentData.filename || 'Document'}\n\n‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§∏‡§ß‡•ç‡§Ø‡§æ ‡§Ü‡§Æ‡•ç‡§π‡•Ä ‡§¶‡§∏‡•ç‡§§‡§ê‡§µ‡§ú ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§ï‡§∞‡§§ ‡§®‡§æ‡§π‡•Ä.\nThank you! We currently don't support document processing.\n\nüí° *‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Æ‡§ú‡§ï‡•Ç‡§∞ ‡§Æ‡•ç‡§π‡§£‡•Ç‡§® ‡§≤‡§ø‡§π‡§æ*\nüí° *Please describe your issue as text*\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, response);

  } catch (error) {
    logger.critical('üí• Error handling document message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle video messages
 */
async function handleVideoMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    const videoData = messageData.video;
    
    logger.debug('üé• Video message received', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      mimeType: videoData.mime_type,
      hasCaption: !!videoData.caption,
      requestId,
      timestamp: new Date().toISOString()
    });

    // Save video message
    await saveChatMessage(phoneNumber, {
      messageId: messageData.id,
      sender: phoneNumber,
      senderName: displayName,
      receiver: 'pcmc_bot',
      messageType: 'video',
      content: `Video shared${videoData.caption ? `: ${videoData.caption}` : ''}`,
      videoMetadata: {
        mediaId: videoData.id,
        mimeType: videoData.mime_type,
        caption: videoData.caption || null
      },
      intent: 'video_sharing',
      context: 'media_upload',
      conversationState: 'video_received',
      language: 'auto',
      ethicalScore: 8,
      botModeEnabled: true,
      requestId
    });

    const response = `üé• *‡§µ‡•ç‡§π‡§ø‡§°‡§ø‡§ì ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ù‡§æ‡§≤‡§æ* | *Video Received*\n\n‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§∏‡§ß‡•ç‡§Ø‡§æ ‡§Ü‡§Æ‡•ç‡§π‡•Ä ‡§µ‡•ç‡§π‡§ø‡§°‡§ø‡§ì ‡§™‡•ç‡§∞‡§ï‡•ç‡§∞‡§ø‡§Ø‡§æ ‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§ï‡§∞‡§§ ‡§®‡§æ‡§π‡•Ä.\nThank you! We currently don't support video processing.\n\nüí° *‡§ï‡•É‡§™‡§Ø‡§æ ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Æ‡§ú‡§ï‡•Ç‡§∞ ‡§Æ‡•ç‡§π‡§£‡•Ç‡§® ‡§≤‡§ø‡§π‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§´‡•ã‡§ü‡•ã ‡§™‡§æ‡§†‡§µ‡§æ*\nüí° *Please describe your issue as text or send a photo*\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, response);

  } catch (error) {
    logger.critical('üí• Error handling video message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle sticker messages
 */
async function handleStickerMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    logger.debug('üòÄ Sticker message received', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });

    // Save sticker message
    await saveChatMessage(phoneNumber, {
      messageId: messageData.id,
      sender: phoneNumber,
      senderName: displayName,
      receiver: 'pcmc_bot',
      messageType: 'sticker',
      content: 'Sticker sent',
      stickerMetadata: {
        mediaId: messageData.sticker.id,
        animated: messageData.sticker.animated || false
      },
      intent: 'casual_interaction',
      context: 'sticker_chat',
      conversationState: 'casual',
      language: 'auto',
      ethicalScore: 9,
      botModeEnabled: true,
      requestId
    });

    const response = `üòä *‡§∏‡•ç‡§ü‡§ø‡§ï‡§∞ ‡§Æ‡§ø‡§≥‡§æ‡§≤‡§æ!* | *Sticker received!*\n\nüèõÔ∏è *PCMC ‡§ö‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∂‡•Ä ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•á?*\nüèõÔ∏è *How can PCMC help you?*\n\nüí° ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§≤‡§ø‡§π‡§æ | Type your issue\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, response);

  } catch (error) {
    logger.critical('üí• Error handling sticker message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle contact messages
 */
async function handleContactMessage(messageData, phoneNumber, displayName, requestId) {
  try {
    const contacts = messageData.contacts;
    
    logger.debug('üë• Contact message received', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      contactCount: contacts.length,
      requestId,
      timestamp: new Date().toISOString()
    });

    // Save contacts message
    await saveChatMessage(phoneNumber, {
      messageId: messageData.id,
      sender: phoneNumber,
      senderName: displayName,
      receiver: 'pcmc_bot',
      messageType: 'contacts',
      content: `${contacts.length} contact(s) shared`,
      contactsMetadata: {
        contactCount: contacts.length,
        contacts: contacts.map(contact => ({
          name: contact.name?.formatted_name || 'Unknown',
          phone: contact.phones?.[0]?.phone || null
        }))
      },
      intent: 'contact_sharing',
      context: 'information_sharing',
      conversationState: 'contacts_received',
      language: 'auto',
      ethicalScore: 8,
      botModeEnabled: true,
      requestId
    });

    const response = `üë• *‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§™‡•ç‡§∞‡§æ‡§™‡•ç‡§§ ‡§ù‡§æ‡§≤‡•á* | *Contacts Received*\n\nüìû ${contacts.length} ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§Æ‡§ø‡§≥‡§æ‡§≤‡•á\nüìû ${contacts.length} contact(s) received\n\n‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶! ‡§Ü‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§Æ‡§ø‡§≥‡§æ‡§≤‡•á.\nThank you! We received the contacts.\n\nüèõÔ∏è *PCMC ‡§ö‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∂‡•Ä ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•á?*\nüèõÔ∏è *How can PCMC help you?*\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, response);

  } catch (error) {
    logger.critical('üí• Error handling contact message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Send unsupported message type response
 */
async function sendUnsupportedMessageResponse(phoneNumber, messageType) {
  try {
    const response = `‚ùì *‡§Ö‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞* | *Unsupported Message Type*\n\nüì± *‡§™‡•ç‡§∞‡§ï‡§æ‡§∞:* ${messageType}\nüì± *Type:* ${messageType}\n\n‡§ï‡•É‡§™‡§Ø‡§æ ‡§Æ‡§ú‡§ï‡•Ç‡§∞ ‡§∏‡§Ç‡§¶‡•á‡§∂, ‡§´‡•ã‡§ü‡•ã, ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§ë‡§°‡§ø‡§ì ‡§™‡§æ‡§†‡§µ‡§æ.\nPlease send text message, photo, or audio.\n\nüí° *‡§∏‡§Æ‡§∞‡•ç‡§•‡§ø‡§§ ‡§™‡•ç‡§∞‡§ï‡§æ‡§∞ | Supported types:*\n‚Ä¢ üìù ‡§Æ‡§ú‡§ï‡•Ç‡§∞ | Text\n‚Ä¢ üñºÔ∏è ‡§´‡•ã‡§ü‡•ã | Photo\n‚Ä¢ üéôÔ∏è ‡§ë‡§°‡§ø‡§ì | Audio\n‚Ä¢ üìç ‡§∏‡•ç‡§•‡§æ‡§® | Location\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, response);
  } catch (error) {
    logger.warning('‚ö†Ô∏è Error sending unsupported message response', {
      error: error.message,
      messageType,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle general conversation flow
 */

async function handleGeneralConversation(messageText, phoneNumber, displayName, intentAnalysis, language, requestId) {
  try {
    logger.ai('üí¨ Processing general conversation', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      intent: intentAnalysis.intent,
      language,
      requestId,
      timestamp: new Date().toISOString()
    });
    
    // Get conversation context
    const conversationContext = await getConversationContext(phoneNumber, 5);
    
    // Process with AI
    const aiResponse = await processMessageWithAI(
      messageText, 
      phoneNumber, 
      intentAnalysis, 
      conversationContext,
      language
    );

    await sendText(phoneNumber, aiResponse.message);

    // Save bot response
    await saveChatMessage(phoneNumber, {
      messageId: generateTicketId(8),
      sender: 'pcmc_bot',
      senderName: 'PCMC Assistant',
      receiver: phoneNumber,
      messageType: 'text',
      content: aiResponse.message,
      intent: 'response',
      context: intentAnalysis.context,
      conversationState: 'completed',
      language,
      ethicalScore: 10,
      botModeEnabled: true,
      aiMetadata: {
        originalIntent: intentAnalysis.intent,
        processingTime: Date.now() - Date.now(),
        knowledgeBaseUsed: true,
        responseType: 'general_conversation'
      },
      requestId
    });

    logger.success('‚úÖ General conversation completed successfully', { 
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error in general conversation', { 
      error: error.message,
      stack: error.stack,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
    
    const errorMessage = language === 'marathi' ? 
      'üòî ‡§Æ‡§æ‡§´ ‡§ï‡§∞‡§æ, ‡§Æ‡•Ä ‡§∏‡§ß‡•ç‡§Ø‡§æ ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§ ‡§®‡§æ‡§π‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.\n\nüìû ‡§§‡§æ‡§§‡§°‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä: 020-27475000\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*' :
      'üòî Sorry, I cannot help right now. Please try again.\n\nüìû For urgent help: 020-27475000\n\nüèõÔ∏è *PCMC Service*';
    await sendText(phoneNumber, errorMessage);
  }
}

/*
 * Handle query flow
 */
async function handleQueryFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId) {
  try {
    logger.ai('‚ùì Processing information query', { 
      requestId,
      timestamp: new Date().toISOString()
    });
    
    const conversationContext = await getConversationContext(phoneNumber, 3);
    const aiResponse = await processMessageWithAI(
      messageText, 
      phoneNumber, 
      intentAnalysis, 
      conversationContext,
      language
    );

    await sendText(phoneNumber, aiResponse.message);

    await saveChatMessage(phoneNumber, {
      messageId: generateTicketId(8),
      sender: 'pcmc_bot',
      senderName: 'PCMC Assistant',
      receiver: phoneNumber,
      messageType: 'text',
      content: aiResponse.message,
      intent: 'query_response',
      context: intentAnalysis.context,
      conversationState: 'query_completed',
      language,
      ethicalScore: 10,
      botModeEnabled: true,
      aiMetadata: {
        queryType: intentAnalysis.context,
        knowledgeBaseUsed: true,
        responseType: 'informational'
      },
      requestId
    });

    logger.success('‚úÖ Query processed successfully', { 
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error in query flow', { 
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
    
    const errorMessage = language === 'marathi' ? 
      'üòî ‡§Æ‡§æ‡§π‡§ø‡§§‡•Ä ‡§Æ‡§ø‡§≥‡§µ‡§ø‡§§‡§æ‡§®‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§Ü‡§≤‡•Ä. ‡§ï‡•É‡§™‡§Ø‡§æ ‡§™‡•Å‡§®‡•ç‡§π‡§æ ‡§™‡•ç‡§∞‡§Ø‡§§‡•ç‡§® ‡§ï‡§∞‡§æ.\n\nüìû ‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä: 020-27475000' :
      'üòî Error retrieving information. Please try again.\n\nüìû For help: 020-27475000';
    await sendText(phoneNumber, errorMessage);
  }
}

/*
 * Handle greeting flow
 */
async function handleGreetingFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId) {
  try {
    logger.ai('üëã Processing greeting', { 
      requestId,
      timestamp: new Date().toISOString()
    });
    
    const greeting = language === 'marathi' ? 
      `üôè *‡§®‡§Æ‡§∏‡•ç‡§ï‡§æ‡§∞ ${displayName}!*\n\nüèõÔ∏è *‡§™‡§ø‡§Ç‡§™‡§∞‡•Ä-‡§ö‡§ø‡§Ç‡§ö‡§µ‡§° ‡§Æ‡§π‡§æ‡§®‡§ó‡§∞‡§™‡§æ‡§≤‡§ø‡§ï‡•á‡§§ (PCMC) ‡§Ü‡§™‡§≤‡•á ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§Ü‡§π‡•á!*\n\n‡§Æ‡•Ä ‡§Ü‡§™‡§≤‡§æ AI ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§Ü‡§π‡•á. ‡§Æ‡•Ä ‡§Ü‡§™‡§≤‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•ã:\n\nüíß *‡§™‡§æ‡§£‡•Ä‡§™‡•Å‡§∞‡§µ‡§†‡§æ ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ*\nüóëÔ∏è *‡§ï‡§ö‡§∞‡§æ ‡§µ‡•ç‡§Ø‡§µ‡§∏‡•ç‡§•‡§æ‡§™‡§®*\nüõ£Ô∏è *‡§∞‡§∏‡•ç‡§§‡•á ‡§Ü‡§£‡§ø ‡§¶‡§ø‡§µ‡•á*\nüè• *‡§Ü‡§∞‡•ã‡§ó‡•ç‡§Ø ‡§∏‡•á‡§µ‡§æ*\nüèóÔ∏è *‡§á‡§Æ‡§æ‡§∞‡§§ ‡§™‡§∞‡§µ‡§æ‡§®‡§ó‡•Ä*\nüí∞ *‡§Æ‡§æ‡§≤‡§Æ‡§§‡•ç‡§§‡§æ ‡§ï‡§∞*\nüìã *‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§∏‡•ç‡§•‡§ø‡§§‡•Ä ‡§§‡§™‡§æ‡§∏‡§æ*\n\nüí° *‡§ï‡§∏‡•á ‡§∏‡•Å‡§∞‡•Å‡§µ‡§æ‡§§ ‡§ï‡§∞‡§æ‡§µ‡•Ä:*\n‚Ä¢ ‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§≤‡§ø‡§π‡§æ\n‚Ä¢ "‡§Æ‡§æ‡§ù‡•ç‡§Ø‡§æ ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞‡•Ä" ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡§æ\n‚Ä¢ ‡§´‡•ã‡§ü‡•ã ‡§™‡§æ‡§†‡§µ‡§æ\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*` :
      `üëã *Hello ${displayName}!*\n\nüèõÔ∏è *Welcome to Pimpri-Chinchwad Municipal Corporation (PCMC)!*\n\nI'm your AI assistant. I can help you with:\n\nüíß *Water Supply Issues*\nüóëÔ∏è *Waste Management*\nüõ£Ô∏è *Roads & Street Lights*\nüè• *Health Services*\nüèóÔ∏è *Building Permissions*\nüí∞ *Property Tax*\nüìã *Check Complaint Status*\n\nüí° *How to start:*\n‚Ä¢ Describe your problem\n‚Ä¢ Type "my complaints"\n‚Ä¢ Send a photo\n\nüèõÔ∏è *PCMC Service*`;

    await sendText(phoneNumber, greeting);

    await saveChatMessage(phoneNumber, {
      messageId: generateTicketId(8),
      sender: 'pcmc_bot',
      senderName: 'PCMC Assistant',
      receiver: phoneNumber,
      messageType: 'text',
      content: greeting,
      intent: 'greeting_response',
      context: 'welcome',
      conversationState: 'welcomed',
      language,
      ethicalScore: 10,
      botModeEnabled: true,
      aiMetadata: {
        responseType: 'welcome_message',
        isNewConversation: true
      },
      requestId
    });

    logger.success('‚úÖ Greeting processed successfully', { 
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error in greeting flow', { 
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Handle small talk flow
 */
async function handleSmallTalkFlow(messageText, phoneNumber, displayName, intentAnalysis, language, requestId) {
  try {
    logger.ai('üí¨ Processing small talk', { 
      requestId,
      timestamp: new Date().toISOString()
    });
    
    const smallTalkResponse = language === 'marathi' ? 
      `üòä *‡§ß‡§®‡•ç‡§Ø‡§µ‡§æ‡§¶!*\n\n‡§Æ‡•Ä PCMC AI ‡§∏‡§π‡§æ‡§Ø‡§ï ‡§Ü‡§π‡•á. ‡§Æ‡•Ä ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§≤‡§æ ‡§Æ‡§π‡§æ‡§®‡§ó‡§∞‡§™‡§æ‡§≤‡§ø‡§ï‡•á‡§ö‡•ç‡§Ø‡§æ ‡§∏‡•á‡§µ‡§æ‡§Ç‡§Æ‡§ß‡•ç‡§Ø‡•á ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•ã.\n\nüèõÔ∏è *PCMC ‡§ö‡•Ä ‡§∏‡•á‡§µ‡§æ ‡§ï‡§∂‡•Ä ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§‡•á?*\n\nüí° *‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ ‡§ï‡§ø‡§Ç‡§µ‡§æ ‡§™‡•ç‡§∞‡§∂‡•ç‡§® ‡§∏‡§æ‡§Ç‡§ó‡§æ:*\n‚Ä¢ ‡§™‡§æ‡§£‡•Ä‡§™‡•Å‡§∞‡§µ‡§†‡§æ\n‚Ä¢ ‡§ï‡§ö‡§∞‡§æ ‡§∏‡§Ç‡§ï‡§≤‡§®\n‚Ä¢ ‡§∞‡§∏‡•ç‡§§‡§æ ‡§¶‡•Å‡§∞‡•Å‡§∏‡•ç‡§§‡•Ä\n‚Ä¢ ‡§§‡§ï‡•ç‡§∞‡§æ‡§∞ ‡§∏‡•ç‡§•‡§ø‡§§‡•Ä\n‚Ä¢ ‡§á‡§§‡§∞ ‡§∏‡•á‡§µ‡§æ\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*` :
      `üòä *Thank you!*\n\nI'm the PCMC AI assistant. I can help you with municipal services.\n\nüèõÔ∏è *How can PCMC assist you?*\n\nüí° *Tell me your issue or question:*\n‚Ä¢ Water supply\n‚Ä¢ Waste collection\n‚Ä¢ Road repairs\n‚Ä¢ Complaint status\n‚Ä¢ Other services\n\nüèõÔ∏è *PCMC Service*`;

    await sendText(phoneNumber, smallTalkResponse);

    await saveChatMessage(phoneNumber, {
      messageId: generateTicketId(8),
      sender: 'pcmc_bot',
      senderName: 'PCMC Assistant',
      receiver: phoneNumber,
      messageType: 'text',
      content: smallTalkResponse,
      intent: 'small_talk_response',
      context: 'casual_redirect',
      conversationState: 'redirected_to_service',
      language,
      ethicalScore: 10,
      botModeEnabled: true,
      aiMetadata: {
        responseType: 'casual_redirect',
        redirectedToService: true
      },
      requestId
    });

    logger.success('‚úÖ Small talk processed successfully', { 
      requestId,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error in small talk flow', { 
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Process message status updates (read, delivered, sent, etc.)
 */
async function processMessageStatus(body, requestId) {
  try {
    const status = body.entry[0].changes[0].value.statuses[0];
    const messageId = status.id;
    const statusType = status.status;
    const recipientId = status.recipient_id;
    
    logger.webhook('üìä Message status update', {
      messageId,
      status: statusType,
      recipient: recipientId.replace(/^91/, 'XXX-XXX-'),
      timestamp: status.timestamp,
      requestId
    });

    // Log different status types
    switch (statusType) {
      case 'sent':
        logger.debug(`üì§ Message sent: ${messageId}`);
        break;
      case 'delivered':
        logger.debug(`üì¨ Message delivered: ${messageId}`);
        break;
      case 'read':
        logger.debug(`üëÅÔ∏è Message read: ${messageId}`);
        break;
      case 'failed':
        logger.warning(`‚ùå Message failed: ${messageId}`, {
          error: status.errors?.[0] || 'Unknown error'
        });
        break;
      default:
        logger.debug(`üìä Status update: ${statusType} for ${messageId}`);
    }

    // Optionally update message status in database
    await updateMessageStatus(messageId, statusType, recipientId);

  } catch (error) {
    logger.warning('‚ö†Ô∏è Error processing message status', {
      error: error.message,
      requestId,
      body: JSON.stringify(body).substring(0, 200),
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Update message status in database
 */
async function updateMessageStatus(messageId, status, recipientId) {
  try {
    // This is optional - you can track message delivery status
    const statusUpdate = {
      messageId,
      status,
      recipientId,
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      statusUpdatedAt: new Date().toISOString()
    };

    // You could store this in a message_status collection if needed
    logger.debug('üìä Message status would be updated', statusUpdate);

  } catch (error) {
    logger.warning('‚ö†Ô∏è Error updating message status', { 
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Rate limiting implementation
 */
async function isRateLimited(phoneNumber) {
  try {
    const now = Date.now();
    const userKey = phoneNumber;
    
    if (!rateLimitStore.has(userKey)) {
      rateLimitStore.set(userKey, { count: 1, resetTime: now + RATE_LIMIT_WINDOW });
      return false;
    }

    const userData = rateLimitStore.get(userKey);
    
    if (now > userData.resetTime) {
      // Reset the counter
      rateLimitStore.set(userKey, { count: 1, resetTime: now + RATE_LIMIT_WINDOW });
      return false;
    }

    if (userData.count >= RATE_LIMIT_MAX_MESSAGES) {
      logger.warning('üö´ Rate limit exceeded', {
        phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
        count: userData.count,
        resetTime: new Date(userData.resetTime).toISOString(),
        timestamp: new Date().toISOString()
      });
      return true;
    }

    userData.count++;
    rateLimitStore.set(userKey, userData);
    return false;

  } catch (error) {
    logger.warning('‚ö†Ô∏è Error checking rate limit', { 
      error: error.message,
      timestamp: new Date().toISOString()
    });
    return false; // Allow on error
  }
}

/*
 * Handle rate limit exceeded
 */
async function handleRateLimit(phoneNumber, messageType) {
  try {
    const rateLimitMessage = `üö´ *‡§¶‡§∞ ‡§Æ‡§∞‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§ì‡§≤‡§æ‡§Ç‡§°‡§≤‡•Ä* | *Rate Limit Exceeded*\n\n‚è≥ *‡§ï‡•É‡§™‡§Ø‡§æ 1 ‡§Æ‡§ø‡§®‡§ø‡§ü ‡§™‡•ç‡§∞‡§§‡•Ä‡§ï‡•ç‡§∑‡§æ ‡§ï‡§∞‡§æ*\n‚è≥ *Please wait 1 minute*\n\n‡§§‡•Å‡§Æ‡•ç‡§π‡•Ä ‡§ñ‡•Ç‡§™ ‡§ú‡§≤‡§¶ ‡§∏‡§Ç‡§¶‡•á‡§∂ ‡§™‡§æ‡§†‡§µ‡§§ ‡§Ü‡§π‡§æ‡§§.\nYou're sending messages too quickly.\n\nüí° *‡§§‡§æ‡§§‡§°‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä:* 020-27475000\nüí° *For urgent help:* 020-27475000\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, rateLimitMessage);

    logger.warning('üö´ Rate limit message sent', {
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      messageType,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    logger.critical('üí• Error handling rate limit', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Send emergency error message when processing fails
 */
async function sendEmergencyErrorMessage(phoneNumber) {
  try {
    const emergencyMessage = `üö® *‡§§‡§æ‡§Ç‡§§‡•ç‡§∞‡§ø‡§ï ‡§∏‡§Æ‡§∏‡•ç‡§Ø‡§æ* | *Technical Issue*\n\nüòî ‡§Ü‡§§‡•ç‡§§‡§æ ‡§Æ‡•Ä ‡§Æ‡§¶‡§§ ‡§ï‡§∞‡•Ç ‡§∂‡§ï‡§§ ‡§®‡§æ‡§π‡•Ä.\nüòî I cannot help right now.\n\nüìû *‡§§‡§æ‡§§‡§°‡•Ä‡§ö‡•ç‡§Ø‡§æ ‡§Æ‡§¶‡§§‡•Ä‡§∏‡§æ‡§†‡•Ä:*\nüìû *For urgent help:*\n020-27475000\n\nüïê *‡§ï‡§æ‡§∞‡•ç‡§Ø‡§æ‡§≤‡§Ø‡•Ä‡§® ‡§µ‡•á‡§≥:* ‡§∏‡§ï‡§æ‡§≥‡•Ä 10 ‡§§‡•á ‡§∏‡§Ç‡§ß‡•ç‡§Ø‡§æ‡§ï‡§æ‡§≥‡•Ä 5:30\nüïê *Office Hours:* 10 AM to 5:30 PM\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, emergencyMessage);

  } catch (error) {
    logger.critical('üí• Failed to send emergency error message', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Get pending complaint for user (waiting for location)
 */
async function getPendingComplaintForUser(phoneNumber) {
  try {
    const complaintsRef = admin.firestore().collection('complaints');
    const snapshot = await complaintsRef
      .where('createdBy', '==', phoneNumber)
      .where('status', '==', 'draft')
      .where('requiresLocationSharing', '==', true)
      .orderBy('createdAt', 'desc')
      .limit(1)
      .get();

    if (snapshot.empty) {
      return null;
    }

    const complaintDoc = snapshot.docs[0];
    return { id: complaintDoc.id, ...complaintDoc.data() };

  } catch (error) {
    logger.warning('‚ö†Ô∏è Error getting pending complaint', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      timestamp: new Date().toISOString()
    });
    return null;
  }
}

/*
 * Download audio file from WhatsApp
 */
async function downloadAudioFile(mediaUrl, mediaId) {
  try {
    const tempDir = path.join(process.cwd(), 'temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    
    const fileName = `${mediaId}.ogg`;
    const localPath = path.join(tempDir, fileName);

    const response = await axios.get(mediaUrl, {
      responseType: 'arraybuffer',
      headers: { Authorization: `Bearer ${process.env.WHATSAPP_TOKEN}` },
      timeout: 30000
    });
    
    fs.writeFileSync(localPath, Buffer.from(response.data));
    
    logger.debug('üéôÔ∏è Audio file downloaded', {
      mediaId,
      localPath,
      fileSize: `${(response.data.byteLength / 1024).toFixed(2)} KB`,
      timestamp: new Date().toISOString()
    });
    
    return localPath;
  } catch (error) {
    logger.critical('üí• Error downloading audio file', {
      error: error.message,
      mediaId,
      mediaUrl: mediaUrl.substring(0, 50) + '...',
      timestamp: new Date().toISOString()
    });
    throw error;
  }
}

/*
 * Log message preview for debugging
 */
function logMessagePreview(messageData, messageType) {
  let preview = '';
  
  switch (messageType) {
    case 'text':
      preview = messageData.text.body.substring(0, 100);
      break;
    case 'image':
      preview = messageData.image.caption || 'Image (no caption)';
      break;
    case 'audio':
      preview = 'Audio message';
      break;
    case 'video':
      preview = messageData.video.caption || 'Video (no caption)';
      break;
    case 'document':
      preview = messageData.document.filename || 'Document';
      break;
    case 'location':
      preview = `Location: ${messageData.location.latitude}, ${messageData.location.longitude}`;
      break;
    case 'interactive':
      if (messageData.interactive.type === 'button_reply') {
        preview = `Button: ${messageData.interactive.button_reply.title}`;
      } else if (messageData.interactive.type === 'list_reply') {
        preview = `List: ${messageData.interactive.list_reply.title}`;
      } else {
        preview = `Interactive: ${messageData.interactive.type}`;
      }
      break;
    case 'sticker':
      preview = 'Sticker';
      break;
    case 'contacts':
      preview = `${messageData.contacts.length} contact(s)`;
      break;
    default:
      preview = `Unknown type: ${messageType}`;
  }
  
  logger.debug('üìù Message preview', {
    type: messageType,
    preview: preview.substring(0, 150) + (preview.length > 150 ? '...' : ''),
    messageId: messageData.id,
    timestamp: new Date().toISOString()
  });
}

/*
 * Handle list selection from interactive messages
 */
async function handleListSelection(listId, listTitle, phoneNumber, displayName, requestId) {
  try {
    logger.webhook('üìã List selection received', {
      listId,
      listTitle,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });

    // Save list interaction
    await saveChatMessage(phoneNumber, {
      messageId: generateTicketId(8),
      sender: phoneNumber,
      senderName: displayName,
      receiver: 'pcmc_bot',
      messageType: 'interactive',
      content: `List selected: ${listTitle}`,
      interactiveData: { 
        type: 'list_reply',
        listId, 
        listTitle 
      },
      intent: 'list_selection',
      context: 'interactive_response',
      conversationState: 'list_selected',
      language: 'auto',
      ethicalScore: 9,
      botModeEnabled: true,
      requestId
    });

    // Handle specific list selections
    const response = `‚úÖ *‡§Ø‡§æ‡§¶‡•Ä ‡§®‡§ø‡§µ‡§°‡§≤‡•Ä* | *List Selected*\n\n"${listTitle}"\n\n‡§§‡•Å‡§Æ‡§ö‡•Ä ‡§®‡§ø‡§µ‡§° ‡§®‡•ã‡§Ç‡§¶‡§µ‡§≤‡•Ä ‡§Ü‡§π‡•á.\nYour selection has been recorded.\n\nüèõÔ∏è *PCMC ‡§∏‡•á‡§µ‡§æ*`;
    
    await sendText(phoneNumber, response);

  } catch (error) {
    logger.critical('üí• Error handling list selection', {
      error: error.message,
      phoneNumber: phoneNumber.replace(/^91/, 'XXX-XXX-'),
      requestId,
      timestamp: new Date().toISOString()
    });
  }
}

/*
 * Utility functions for formatting status display
 */
function getStatusEmoji(status) {
  const statusEmojis = {
    'draft': 'üìù',
    'active': 'üîÑ',
    'open': 'üîì',
    'in_progress': '‚öôÔ∏è',
    'resolved': '‚úÖ',
    'closed': 'üîí',
    'cancelled': '‚ùå',
    'pending': '‚è≥'
  };
  return statusEmojis[status] || '‚ùì';
}

function getPriorityEmoji(priority) {
  const priorityEmojis = {
    'emergency': 'üö®',
    'high': 'üî¥',
    'medium': 'üü°',
    'low': 'üü¢'
  };
  return priorityEmojis[priority] || '‚ö™';
}

function getProgressBar(percentage) {
  const filled = Math.floor(percentage / 10);
  const empty = 10 - filled;
  return 'üü©'.repeat(filled) + '‚¨ú'.repeat(empty);
}

function formatDate(timestamp) {
  try {
    let date;
    if (timestamp && typeof timestamp.toDate === 'function') {
      date = timestamp.toDate();
    } else if (timestamp instanceof Date) {
      date = timestamp;
    } else if (typeof timestamp === 'string') {
      date = new Date(timestamp);
    } else {
      return 'Unknown date';
    }
    
    return date.toLocaleDateString('en-IN', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      timeZone: 'Asia/Kolkata'
    });
  } catch (error) {
    return 'Invalid date';
  }
}

/*
 * Clean up old rate limit entries (periodic cleanup)
 */
function cleanupRateLimit() {
  const now = Date.now();
  let cleanedCount = 0;
  
  for (const [key, data] of rateLimitStore.entries()) {
    if (now > data.resetTime) {
      rateLimitStore.delete(key);
      cleanedCount++;
    }
  }
  
  if (cleanedCount > 0) {
    logger.debug(`üßπ Rate limit cleanup: removed ${cleanedCount} expired entries`);
  }
}

// Run cleanup every 5 minutes
setInterval(cleanupRateLimit, 5 * 60 * 1000);

/*
 * Get webhook statistics
 */
function getWebhookStats() {
  return {
    version: WEBHOOK_VERSION,
    lastUpdated: WEBHOOK_UPDATED,
    updatedBy: UPDATED_BY,
    uptime: process.uptime(),
    rateLimitEntries: rateLimitStore.size,
    memoryUsage: process.memoryUsage(),
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development',
    features: {
      complaintStatusQuery: true,
      duplicateDetection: true,
      aiProcessing: true,
      multiLanguageSupport: true,
      rateLimit: true,
      audioTranscription: true,
      imageAnalysis: true,
      locationHandling: true
    },
    performance: {
      maxProcessingTime: MAX_PROCESSING_TIME,
      rateLimitWindow: RATE_LIMIT_WINDOW,
      rateLimitMaxMessages: RATE_LIMIT_MAX_MESSAGES
    }
  };
}

/*
 * Health check endpoint for webhook
 */
async function healthCheck() {
  try {
    const stats = getWebhookStats();
    
    // Test essential services
    const firebaseHealthStart = Date.now();
    const firebaseHealth = await admin.firestore().collection('_health').doc('test').get();
    const firebaseResponseTime = Date.now() - firebaseHealthStart;
    
    const whatsappHealth = process.env.WHATSAPP_TOKEN ? 'configured' : 'missing';
    const openaiHealth = process.env.OPENAI_API_KEY ? 'configured' : 'missing';
    const googleMapsHealth = process.env.GOOGLE_MAPS_API_KEY ? 'configured' : 'missing';
    
    return {
      status: 'healthy',
      webhook: stats,
      services: {
        firebase: {
          status: firebaseHealth.exists ? 'operational' : 'error',
          responseTime: firebaseResponseTime
        },
        whatsapp: whatsappHealth,
        openai: openaiHealth,
        googleMaps: googleMapsHealth,
        rateLimiting: 'operational'
      },
      configuration: {
        maxProcessingTime: MAX_PROCESSING_TIME,
        rateLimitWindow: RATE_LIMIT_WINDOW,
        rateLimitMaxMessages: RATE_LIMIT_MAX_MESSAGES,
        supportedLanguages: ['english', 'marathi'],
        supportedMessageTypes: ['text', 'audio', 'image', 'location', 'interactive', 'document', 'video', 'sticker', 'contacts']
      },
      timestamp: new Date().toISOString(),
      deployedBy: UPDATED_BY,
      lastDeployment: WEBHOOK_UPDATED
    };
  } catch (error) {
    return {
      status: 'unhealthy',
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      version: WEBHOOK_VERSION
    };
  }
}

/*
 * Graceful shutdown handler
 */
function setupGracefulShutdown() {
  const gracefulShutdown = (signal) => {
    logger.info(`üõë Received ${signal}. Starting graceful shutdown...`);
    
    // Clear rate limit store
    rateLimitStore.clear();
    
    // Log final statistics
    const finalStats = getWebhookStats();
    logger.info('üìä Final webhook statistics', finalStats);
    
    process.exit(0);
  };

  process.on('SIGINT', () => gracefulShutdown('SIGINT'));
  process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
}

// Initialize graceful shutdown
setupGracefulShutdown();

/*
 * Webhook initialization
 */
function initializeWebhook() {
  logger.info('üöÄ Webhook controller initialized', {
    version: WEBHOOK_VERSION,
    timestamp: new Date().toISOString(),
    updatedBy: UPDATED_BY,
    lastUpdated: WEBHOOK_UPDATED,
    features: {
      complaintStatusQuery: '‚úÖ Enabled',
      duplicateDetection: '‚úÖ Enabled', 
      aiProcessing: '‚úÖ Enabled',
      rateLimit: '‚úÖ Enabled',
      audioTranscription: '‚úÖ Enabled',
      imageAnalysis: '‚úÖ Enabled',
      locationHandling: '‚úÖ Enabled',
      multiLanguage: '‚úÖ Enabled (English/Marathi)'
    }
  });
}

// Initialize on module load
initializeWebhook();

// Export the main handler and utility functions
module.exports = {
  handleWebhook,
  healthCheck,
  getWebhookStats,
  
  // Export individual handlers for testing
  processIncomingMessage,
  handleTextMessage,
  handleAudioMessage,
  handleImageMessage,
  handleLocationMessage,
  handleInteractiveMessage,
  handleComplaintStatusQuery,
  handleComplaintFlow,
  sendComplaintConfirmation,
  
  // Flow handlers
  handleGeneralConversation,
  handleQueryFlow,
  handleGreetingFlow,
  handleSmallTalkFlow,
  
  // Interactive handlers
  handleComplaintConfirmation,
  handleComplaintCancellation,
  handleListSelection,
  
  // Message type handlers
  handleDocumentMessage,
  handleVideoMessage,
  handleStickerMessage,
  handleContactMessage,
  
  // Utility functions
  isRateLimited,
  handleRateLimit,
  getPendingComplaintForUser,
  downloadAudioFile,
  formatComplaintStatusMessage,
  getStatusEmoji,
  getPriorityEmoji,
  getProgressBar,
  formatDate,
  logMessagePreview,
  sendUnsupportedMessageResponse,
  sendEmergencyErrorMessage,
  
  // Configuration constants
  WEBHOOK_VERSION,
  WEBHOOK_UPDATED,
  UPDATED_BY,
  MAX_PROCESSING_TIME,
  RATE_LIMIT_WINDOW,
  RATE_LIMIT_MAX_MESSAGES
};